#!/usr/bin/env python3
#
############################################################################
#
# MODULE:      t.water.hazard
# AUTHOR(S):   Guido Riembauer
#
# PURPOSE:     takes an input watermask STRDS generated by t.sentinel_1.watermasks
#              and calculates flood frequency and flood depth maps from it.
#
# COPYRIGHT:    (C) 2020-2022 by mundialis GmbH & Co. KG and the GRASS Development Team
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#############################################################################
# %Module
# % description: Takes an input watermask STRDS generated by t.sentinel_1.watermasks and calculates flood frequency and flood depth maps from it.
# % keyword: display
# % keyword: raster
# %End

# %option
# % key: input
# % type: string
# % required: yes
# % multiple: no
# % label: Input space time raster dataset (STRDS) containing water masks
# % description: Use t.sentinel_1.watermasks to calculate the STRDS
# %end

# %option
# % key: dem
# % type: string
# % required: no
# % multiple: no
# % label: Input DEM to calculate flood depth
# % description: Input DEM to calculate flood depth
# %end

# %option
# % key: output_frequency
# % type: string
# % required: yes
# % multiple: no
# % label: Output flood frequency map
# %end

# %option
# % key: output_permwater
# % type: string
# % required: no
# % multiple: no
# % label: Output permanent water raster
# %end

# %option
# % key: input_permwater
# % type: string
# % required: no
# % multiple: no
# % label: Input permanent water raster
# % description: Only valid if -p flag is set. No output permanent water map will be produced
# %end

# %option
# % key: output_countdates
# % type: string
# % required: no
# % multiple: no
# % label: Output raster map with no. of scenes per pixel
# %end

# %option
# % key: output_flooddepth
# % type: string
# % required: no
# % multiple: no
# % label: Output raster map with flooddepth statistics
# %end

# %option
# % key: flooddepth_parameter
# % type: string
# % required: no
# % multiple: no
# % label: Flooddepth statistic
# % description: Used to aggregate the individual flood depth rasters
# % options: average, median, minimum, maximum, range, quart1, quart3, perc90
# % answer: median
# %end

# %option
# % key: perm_threshold
# % type: integer
# % required: no
# % multiple: no
# % label: Pixels that are water [perm_threshold]% of the times are classified as permanent water
# % answer: 50
# %end

# %flag
# % key: r
# % description: Calculate relative flood frequency as percentage of flood pixel occurence relative to total coverages
# %end

# %flag
# % key: d
# % description: Estimate flood depth based on input DEM
# %end

# %flag
# % key: p
# % description: Don't estimate permanent water bodies, provide water body input raster instead
# %end

# %rules
# % collective: -d, dem, output_flooddepth
# %end

# %rules
# % collective: -p, input_permwater
# %end

# %rules
# % exclusive: -p, output_permwater
# %end


import os
import atexit
import grass.script as grass

# define lists to cleanup
rm_regions = []
rm_vectors = []
rm_rasters = []
rm_strds = []
oldmask = None


def cleanup():
    """
    Function that loops through global lists with regions, vectors, rasters,
    and groups and removes all items.
    """

    nuldev = open(os.devnull, "w")
    kwargs = {"flags": "f", "quiet": True, "stderr": nuldev}
    if oldmask:
        grass.run_command("r.mask", raster=oldmask)
        rm_rasters.append(oldmask)
    for rmr in rm_strds:
        try:
            grass.run_command("t.remove", inputs=rmr)
        except Exception:
            grass.warning(_("Unable to remove %s") % (rmr))
    for rmr in rm_regions:
        if rmr in [x for x in grass.parse_command("g.list", type="region")]:
            grass.run_command("g.remove", type="region", name=rmr, **kwargs)
    for rmv in rm_vectors:
        if grass.find_file(name=rmv, element="vector")["file"]:
            grass.run_command("g.remove", type="vector", name=rmv, **kwargs)
    for rmrast in rm_rasters:
        if grass.find_file(name=rmrast, element="raster")["file"]:
            grass.run_command("g.remove", type="raster", name=rmrast, **kwargs)


def main():
    global rm_regions, rm_vectors, rm_rasters, rm_strds, oldmask
    # get the user parameters
    input = options["input"]
    output_freq = options["output_frequency"]
    if flags["d"]:
        flooddepth_rasters = []

    # put together all rasters from the same date and create new strds
    rasters = list(grass.parse_command("t.rast.list", input=input).keys())[1:]
    unique_dates = list(set([raster.split("|")[2] for raster in rasters]))
    combine_rasters = []
    combine_dates = []
    for date in unique_dates:
        rasters_samedate = []
        for raster in rasters:
            if date == raster.split("|")[2]:
                rasters_samedate.append(raster.split("|")[0])
        combine_rasters.append(rasters_samedate)
        combine_dates.append(date.split(" ")[0])

    grass.message(_("Identified %d unique dates." % len(unique_dates)))
    tmp_strds = "strds_%s" % (os.getpid())
    grass.run_command(
        "t.create", output=tmp_strds, title=tmp_strds, description=tmp_strds
    )
    rm_strds.append(tmp_strds)

    combined_maps = []
    for idx, rasterlist in enumerate(combine_rasters):
        combined_map = "combined_%s" % combine_dates[idx].replace("-", "")
        rm_rasters.append(combined_map)
        combined_maps.append(combined_map)
        if len(rasterlist) > 1:
            ifstring1 = " ||| ".join([" not(isnull(%s)) " % map for map in rasterlist])
            ifstring2 = "nmax(%s)" % ",".join([map for map in rasterlist])
        elif len(rasterlist) == 1:
            ifstring1 = " not(isnull(%s))" % rasterlist[0]
            ifstring2 = "nmax(%s)" % rasterlist[0]
        expression = "%s = if(%s, %s, null())" % (combined_map, ifstring1, ifstring2)
        grass.run_command(
            "r.mapcalc", expression=expression, overwrite=True, quiet=True
        )
        grass.run_command(
            "t.register",
            input=tmp_strds,
            maps=combined_map,
            start=combine_dates[idx],
            end=combine_dates[idx],
            overwrite=True,
            quiet=True,
        )
        grass.message(_("Created and registered raster map %s" % combined_map))

        # flood depth calculation
        # has to be done for each timestep individually --> timeconsuming
        if flags["d"]:
            dem = options["dem"]
            grass.message(_("Calculating flood depth..."))
            # prepare output raster
            combined_map_flooddepth = "flooddepth_%s" % (
                combine_dates[idx].replace("-", "")
            )
            rm_rasters.append(combined_map_flooddepth)
            # test if there are any water pixels
            stats = grass.parse_command("r.univar", map=combined_map, flags="g")
            try:
                sum = int(stats["sum"])
            except Exception:
                sum = 0

            if sum > 0:
                if grass.find_file(name="MASK", element="raster")["file"]:
                    oldmask = "mask_%s" % os.getpid()
                    grass.run_command(
                        "g.rename", raster="MASK,%s" % oldmask, quiet=True
                    )
                # set mask
                grass.run_command(
                    "r.mask",
                    raster=combined_map,
                    maskcats="1",
                    overwrite=True,
                    quiet=True,
                )
                rm_rasters.append("MASK")
                # generate clumped dataset
                clumped = "clumped_%s" % os.getpid()
                rm_rasters.append(clumped)
                grass.run_command(
                    "r.clump",
                    input=combined_map,
                    output=clumped,
                    overwrite=True,
                    quiet=True,
                )
                # get negative buffer
                clumped_shrunk = "clumped_shrunk_%s" % os.getpid()
                rm_rasters.append(clumped_shrunk)
                grass.run_command(
                    "r.grow",
                    input=clumped,
                    radius="-1.01",
                    output=clumped_shrunk,
                    overwrite=True,
                    quiet=True,
                )
                # get the boundary only and assign dem values to it
                boundary_dem = "boundary_dem_%s" % os.getpid()
                rm_rasters.append(boundary_dem)
                expression_boundary = "%s = if(not(isnull(%s)),null(),%s)" % (
                    boundary_dem,
                    clumped_shrunk,
                    dem,
                )
                grass.run_command(
                    "r.mapcalc",
                    expression=expression_boundary,
                    overwrite=True,
                    quiet=True,
                )
                # calculate the median altitude for all boundaries and assign them to the clump
                water_level_abs = "water_level_abs_%s" % os.getpid()
                rm_rasters.append(water_level_abs)
                grass.run_command(
                    "r.stats.quantile",
                    cover=boundary_dem,
                    base=clumped,
                    percentiles="50",
                    output=water_level_abs,
                    overwrite=True,
                    quiet=True,
                )
                grass.run_command("r.mask", flags="r", quiet=True)
                final_expression = "%s = if(%s > %s, 0,%s - %s)" % (
                    combined_map_flooddepth,
                    dem,
                    water_level_abs,
                    water_level_abs,
                    dem,
                )
            else:
                grass.message(
                    _("No water pixels found," " skipping flood depth calculation")
                )
                # if there are no water pixels, create null() raster
                final_expression = "%s = null()" % combined_map_flooddepth

            # calculate relative to dem
            grass.run_command("r.mapcalc", expression=final_expression, quiet=True)
            grass.message(_("Created flood depth map %s" % (combined_map_flooddepth)))
            flooddepth_rasters.append(combined_map_flooddepth)

    # count number of maps per date
    grass.message(_("Calculating temporal coverage..."))
    if options["output_countdates"]:
        output_count = options["output_countdates"]
    else:
        output_count = "count_%s" % os.getpid()
        rm_rasters.append(output_count)

    grass.run_command(
        "t.rast.series",
        input=tmp_strds,
        method="count",
        output=output_count,
        quiet=True,
    )
    if options["output_countdates"]:
        grass.message(_("Created raster map <%s>" % output_count))

    # calculate initial sum of all rasters
    sumraster = "sumraster_%s" % os.getpid()
    rm_rasters.append(sumraster)
    grass.run_command("t.rast.series", input=tmp_strds, method="sum", output=sumraster)

    if not flags["p"]:
        # get permanent water bodies from percentage threshold
        grass.message(_("Calculating permanent water bodies..."))
        thresh = int(options["perm_threshold"])
        thresh_rast = "threshraster_%s" % os.getpid()
        rm_rasters.append(thresh_rast)
        # calculate pixelwise threshold based on pixelwise scene count
        expression_thresh = "%s = round(0.01 * %d * %s)" % (
            thresh_rast,
            thresh,
            output_count,
        )
        grass.run_command("r.mapcalc", expression=expression_thresh)
        if options["output_permwater"]:
            permwatermap = options["output_permwater"]
        else:
            permwatermap = "permwatermap_%s" % os.getpid()
            rm_rasters.append(permwatermap)
        grass.run_command(
            "r.mapcalc",
            expression="%s = if(%s>=%s,1,null())"
            % (permwatermap, sumraster, thresh_rast),
        )
        if options["output_permwater"]:
            grass.message(_("Created raster map <%s>" % permwatermap))
    else:
        permwatermap = options["input_permwater"]

    # get flood frequency map
    # either calculate relative or absolute occurence
    grass.message(_("Calculating flood frequency map..."))
    if flags["r"]:
        expression = "%s = if(isnull(%s),round(%s/%s*100),null())" % (
            output_freq,
            permwatermap,
            sumraster,
            output_count,
        )
    else:
        expression = "%s = if(isnull(%s),%s,null())" % (
            output_freq,
            permwatermap,
            sumraster,
        )
    grass.run_command("r.mapcalc", expression=expression)
    grass.run_command("r.null", map=output_freq, setnull=0)
    grass.message(_("Created raster map <%s>" % output_freq))

    # get aggregated flood depth map
    if flags["d"]:
        grass.message(_("Calculating flood depth aggregation..."))
        flooddepth_output = options["output_flooddepth"]
        method = options["flooddepth_parameter"]
        flooddepth_temp = "flooddepth_temp_%s" % os.getpid()
        rm_rasters.append(flooddepth_temp)
        grass.run_command(
            "r.series", input=flooddepth_rasters, method=method, output=flooddepth_temp
        )
        grass.run_command(
            "r.mapcalc",
            expression="%s = if(not(isnull(%s)),null(),%s)"
            % (flooddepth_output, permwatermap, flooddepth_temp),
        )
        grass.message(_("Created raster map <%s>" % flooddepth_output))


if __name__ == "__main__":
    options, flags = grass.parser()
    atexit.register(cleanup)
    main()
